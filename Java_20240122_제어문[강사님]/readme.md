# 파이썬(Python)
## 변수와 데이터 타입
### 변수
    컴퓨터는 처리에 사용할 데이터를 메모리의 특정 위치에 저장하게 되는데 필요시에 저장된 데이터를 로딩할 경우
    데이터의 위치인 주소에 위해서 접근하게 된다. 그러나, 개발자가 그러한 주소를 일일히 외워두기 만무하므로
    주소 대신 알기 쉬운 이름으로 대신하여 개발자가 처리에 필요한 데이터를 저장하여 처리될 수 있도록 하되
    그 데이터는 수시로 변할 수 있으므로 그 것을 우리는 변수 또는 변수명이라고 한다.
 
### 변수의 데이터 타입
    파이썬에서는 저장할 데이터를 리터럴(Literal)이라고 하는데 그 저장하는 데이터의 종류에 따라 변수의 타입이
    결정이 된다. 그 변수의 데이터 타입에는 정수(int), 실수(float), 논리(bool), 문자열(str), 복소수(complex) 등의
    하나의 데이터만을 기억하는 기본형 데이터 타입과 목록(list), 튜플(tuple), 모음(set), 사전(dict) 등 집합형태의
    여러 데이터를 저장하는 참조형(컬렉션:Collection) 데이터 타입인 이더레이터(iteraters) 등이 있다.
<br>
  
### 변수의 선언과 초기화
```Python
변수명 = 리터럴
print(id(변수명))      # id(변수명)은 해당 변수의 메모리 주소를 알 수 있음
```
<br>
  
### 기본형 데이터 타입
|타입|설명| 표현 예시                              |
|-------|-------------------------|------------------------------------|
|int|정수형 데이터| 1004(10진수),0x3DF(16진수), 0o756(8진수) |
|float|실수형 데이터| i=3.14                             |
|bool|논리형 데이터| i=True                             |
|str|문자열 데이터| name='kim'                         |
```Python
변수명 = 리터럴
print(type(변수명))    # type(변수명)은 해당 변수의 데이터 타입을 알 수 있음
```  
<br>  
  
### 형변환(Casting)
예시
```Python
# 정수 형변환
a="100"
b=True
c=42.195
print(type(int(a)), int(a))
print(type(int(b)), int(b))
print(type(int(c)), int(c))
# 실수 형변환
print(type(float(a)), float(a))
print(type(float(b)), float(b))
print(type(float(c)), float(c))
# 논리 형변환
print(type(bool(a)), bool(a))
print(type(bool(b)), bool(b))
print(type(bool(c)), bool(c))
# 문자열 형변환
print(type(str(a)), str(a))
print(type(str(b)), str(b))
print(type(str(c)), str(c))
```
<br>
  
## 연산자
<br>
  
### 산술 연산자
| 연산자 | 설명   | 표현 예시  |
|-----|------|--------|
| +   | 덧셈   | a=b+5  |
| -   | 뺄셈   | a=b-5  |
| *   | 곱셈   | a=b*5  |
| /   | 나눗셈  | a=b/5  |
| %   | 나머지  | a=b%5  |
| //  | 몫    | a=b//5 |
| **  | 거듭제곱 | a=b**5 |
<br>
  
### 비교 연산자
| 연산자 | 설명  | 표현 예시   |
|-----|-----|---------|
| >   | 초과  | a>b     |
| >=  | 이상  | a>=b    |
| <   | 미만  | a<b     |
| <=  | 이하  | a<=b    |
| ==  | 일치  | a==b    |
| !=  | 불일치 | a!=b |
<br>
  
### 논리 연산자
| 연산자 | 설명   | 표현 예시      |
|-----|------|-------------|
| and | 논리곱  | a>b and b>c |
| or  | 논리합  | a>b or b>c  |
| not | 논리부정 | not a>b     |
<br>
  
### 할당(대입) 연산자
| 연산자 | 설명     | 표현 예시                |
|-----|--------|----------------------|
| =   | 대입     | a=5                  |
| =   | 교환     | a,b = b,a            |
| =   | 할당     | a,*b = [10,20,30,40] |
| +=  | 증가     | a+=5                 |
| -=  | 감소     | a-=5                 |
| *=  | 곱하기 대입 | a*=b                 |
| /=  | 나누기 대입 | a/=b                 |
| %=  | 나머지 대입 | a%=b                 |
<br>

### 비트 연산자
| 연산자    | 설명         | 표현 예시      |
|--------|------------|------------|
| &      | 2진수 and 연산 | a=b&5      |
| &#124; | 2진수 or 연산  | a=b&#124;5 |
| ^      | 2진수 xor연산  | a=b^5      |
| ~      | 2진수 보수     | a=~b       |
| >>     | 2진수 오른쪽시프트 | a=b>>5     |
| <<     | 2진수 왼쪽시프트  | a=b<<5     |
<br>
<br>
  
## 문자열 처리
    문자열 데이터는 작은 따옴표(')와 큰 따옴표(")로 감싸면 문자열로 인식되며, 여러 줄에 걸쳐 처리할 경우 작은 따옴표나 
    큰 따옴표 세 개로 감싸고, 그 안에 여러 줄로 줄바꿈도 그대로 입력하면, 하나의 문장으로 할당된다.
예시
```Python
s1 = '한 줄 데이터'
s2 = "한 줄 데이터"
s3 = '''여러 줄로
구성된
문장 형식의 데이터
'''
s4 = """여러 줄로\n구성된\n문장 형식의 데이터"""
s5 = "지역: %s, 소속: %s, 건수: %d" % ("서울", "한양대", 38)
s6 = "D:\\kim\\test\\number.txt"       # 파일 경로1
s7 = r"D:\kim\test\number.txt"         # 파일 경로2
```
<br>

### 문자열의 입출력용 이스케이프 문자
| 형식코드 | 설명           |
|------|--------------|
| \n	  | 줄바꿈 처리       |
| \t	  | 탭 간격 처리      |
| \r	  | 캐리지 리턴 처리    |
| \f   | 폼피드 기능       |
| \b   | 백스페이스 기능     |
| \\   | \ 처리         |
| \'   | '(작은 따옴표) 처리 |
| \"   | "(큰 따옴표) 처리  |
| \000 | 널 문자 처리      |
<br>
  

### 문자열 입출력 형식
|형식코드| 설명                           |
|------|------------------------------|
|%s	| 문자열 (파이썬 객체를 str()을 사용하여 변환) |
|%r	|문자열 (파이썬 객체를 repr()을 사용하여 변환)|
|%c	|문자(char)|
|%d 또는 %i|	정수 (int)|
|%f 또는 %F|	부동소수 (float) (%f 소문자 / %F 대문자)|
|%e 또는 %E|	지수형 부동소수 (소문자 / 대문자)|
|%g 또는 %G|	일반형: 값에 따라 %e 혹은 %f 사용 (소문자 / 대문자)|
|%o 또는 %O|	8진수 (소문자 / 대문자)|
|%x 또는 %X|	16진수 (소문자 / 대문자)|
|%%|	% 퍼센트 리터럴|
<br>
  
### 문자열 색인과 연산
예시
```Python
data = "I\'m a boy~! You \'re a girl"
# 변수명[시작:끝:간격]
print(data[3])  # 인덱스가 3인 문자
print(data[1:5])    # 인덱스가 1인 글자부터 5전까지인 문자 - 슬라이싱1
print(data[3:])    # 인덱스가 3인 글자부터 끝까지 문자 - 슬라이싱2
print(data[:5])    # 처음 부터 인덱스가 5인 전까지 문자 - 슬라이싱3
print(data[::2])    # 처음 부터 인덱스가 짝수 인 문자 - 슬라이싱4
print(data[::-1])    # 뒤에서 부터 - 슬라이싱5
print(data*5)   # 문장 반복
```
<br>
  

### 문자열 관련 메소드
| 함수                                                      | 설명                                                          |사용법|
|---------------------------------------------------------|-------------------------------------------------------------|-------------|
| upper()                                                 | 소문자를 대문자로 변환                                                |string.upper()|
| lower()                                                 | 대문자를 소문자로 변환                                                |string.lower()|
| swapcase()                                              | 대문자는 소문자로, 소문자는 대문자로 변환                                     |string.swapcase()|
| title()                                                 | 각 단어의 앞글자만 대문자로 변환합니다. 만약 각 단어 중간에 대문자가 있다면 소문자로 변환         |string.title()|
| count()                                                 | 문자열에서 "찾을 문자열"이 몇 개 있는지 개수를 센다                              |string.count("찾을 문자열")|
| find()                                                  | 문자열에서 "찾을 문자열"이 왼쪽(0)부터 시작해서 몇번째에 위치하는지 알아내기                |string.find("찾을 문자열") |                  
| rfind()                                                 | find()와 다르게 반대편에서부터 찾기                                      |string.rfind("찾을 문자열")                                      |      
| index()                                                 | find()와 기능이 동일합니다. 다만 해당 문자열이 없으면 -1를 반환하는 find와 달리 오류 발생   |string.index("찾을 문자열") | 
| rindex()                                                | index()와 다르게 반대편에서부터 찾기                                     |string.rindex("찾을 문자열")                                      | 
| startwith()                                             | "찾을 문자열"로부터 문자열이 시작되면 True 아니면 False를 반환                    |string.startswith("찾을 문자열")             |
| endswith()                                              | "찾을 문자열"이 문자열의 마지막이면 True 아니면 False를 반환                     |string.endswith("찾을 문자열")                 |
| strip()                                                 | 양 쪽의 공백을 삭제해줍니다. 주의할 점은 문자열 중간에 있는 공백은 삭제해주지 않음             |string.strip()|
| rstrip()|오른쪽 공백을 삭제 주의할 점은 문자열 중간에 있는 공백은 삭제해주지 않음 |string.rstrip()|
| lstrip()|왼쪽 공백을 삭제 주의할 점은 문자열 중간에 있는 공백은 삭제해주지 않음  |string.lstrip() |
| replace()                                               | "기존 문자열"을 "새 문자열"로 변경해줍니다.	string.replace("기존 문자열","새 문자열") |
| split()                                                 | 문자열을 공백이나 다른 문자로 분리해 리스트로 반환합니다	string.split()              |string.split("분리할 문자")|
| join()                                                  | 문자열 결합연산                                                    |string.join("join할 문자열")|
| map()                                                   | map(함수명, 리스트명) 함수는 리스트값 하나하나를 함수명에 대입                       |map("함수명","리스트명")|
| isdigit()                                               | 숫자로만 구성되어 있는지 확인                                            |string.isdigit()|
| isalpha()                                               | 문자로만 구성되어 있는지 확인                                            |string.isalpha()|
| isalnum()                                               | 숫자,문자로 구성되어 있는지 확인                                          |string.isalnum()|
| islower()                                               | 소문자로만 구성되어 있는지 확인                                           |string.islower()|
| isupper()                                               | 대문자로만 구성되어 있는지 확인                                           |string.isupper()|
| isspace()                                               | 공백으로만 구성되어 있는지 확인                                           |string.isspace()|
<br>

<br>

--------------------------------------------------------------------------------

## 제어문
    프로그램의 실행을 제어하는 구문으로 프로그램의 흐름과 처리방법, 입력과 출력의 분기와 반복 등을 제어한다.
    파이썬의 제어문은 조건문, 반복문, 기타 제어문으로 나누어 지며, 조건문은 if~elif~else문이 있으며, 반복문에는 
    while문, for~in문, for~in~range문 등을 활용하고, 기타 제어문으로는 continue와 break가 있다.
<br>
  
### 조건문
    파이썬에서의 조건문은 if문을 활용한다.
<br>
  

#### if문
    주어진 조건에 의하여 참일 때와 거짓 일 때 처리해야 할 일들을 다르게 처리할 수 있도록 해주는 명령문
```Python
if(조건식1):
    조건식1이 참일 때 실행할 문장
[elif(조건식2):
    조건식2가 참일 때 실행할 문장]
......
[elif(조건식n):
    조건식n이 참일 때 실행할 문장]
[else:
    모든 조건이 만족하지 않을 때 실행할 문장]
```
**※ 파이썬에서 프로그램 블록은 다른 프로그래밍 언어처럼 중괄호({})로 구분하지 않고, 탭(Tab)으로 구분한다.
또한, 필요에 따라 elif문장이나 else 문장을 사용할 수 도 있으나 if 문장은 생략하지 못한다.
조건식은 연산자를 참조하여 작성하기 바람**
<br>
  
### 반복문
    파이썬의 반복문은 주어진 조건에 따라 반복횟수를 달리하는 while문과 객체가 가지는 갯수만큼 반복되는 for문이 있다.
<br>
#### while문
    조건이 만족하는 동안 반복실행하는 문장으로 카운트 변수를 별도로 기재하고, 반복실행할 구문을 반복시키는 구조이다.
```Python
카운트변수=초기값
while 조건식:
    [반복실행할 문장]
    [카운트변수증감식]
```
**※ 파이썬에서 프로그램 블록은 다른 프로그래밍 언어처럼 중괄호({})로 구분하지 않고, 탭(Tab)으로 구분한다.
또한, 파이썬의 while구문만 조건이 항상 만족이 되면, 무한 루프로서 무한정 계속 실행하게 된다.**
<br>
  
#### for 문
    파이썬에서의 for문은 객체(컬렉션)가 가지고 있는 요소의 수 만큼 반복되게 하거나 특정 범위만큼 반복되게 할 수 있는
    반복문이다.
```Python
for 지역변수 in 컬렉션타입객체:
    반복실행할 문장
```
```Python
for 지역변수 in range(시작값, 종료값):
    반복실행할 문장
```
**※ 파이썬에서 프로그램 블록은 다른 프로그래밍 언어처럼 중괄호({})로 구분하지 않고, 탭(Tab)으로 구분한다.
또한, 파이썬의 for구문의 컬렉션타입에는 list, tuple, set, dict 등이 있다**
<br>

### 기타 제어문
    파이썬의 기타 제어문에는 실행을 중지하는 break문과 실행구간을 건너띄는 continue가 있다.
<br>

#### break문 
    if문의 조건이 만족하게 되면, 반복 실행을 중지하고, 루프를 벗어나게 된다.
```Python
반복문:
    if(조건식):
        break
```

#### continue
    if문의 조건이 만족하게 되면, 반복실행할 문장을 실행하지 않고, 구간을 건너띄게 된다.

```Python
반복문:
    if(조건식):
        continue        
    반복실행할 문장
```
<br>

-----------------------------------------------------

<br>
## 컬렉션(Collection)
    복수 개의 데이터를 저장하는 자료구조 형태로 파이썬에서 제공하는 것에는 list, tuple, set, dict 등이 있다.

### list(리스트)
    다른 프로그래밍언어에서의 배열과 같이 대괄호 "[]"로 묶어서 선언하게 되며, 인덱스(순번)에 의한 순서제어가 가능하며,
    요소들의 값이 중복될 수도 있으며, 자유롭게 요소를 추가, 삽입, 삭제, 변경, 합치기, 분리하기, 형변환 등이 가능하다.
    또한, 리스트는 복합체이므로, 각 각 저장된 값들을 요소라고 한다.
```Python
리스트명 = [값1, 값2, 값3,....]       # 리스트 선언
리스트명[인덱스]=값         # 특정 요소에 접근 가능하며, 그 요소의 값도 변경할 수 있음
del 리스트명[인덱스]    # 특정 위치의 요소 삭제
len(리스트명)   # 리스트의 요소 개수
리스트명=리스트1+리스트2    # 리스트 합치기
리스트명.extend(리스트1)    # 리스트 확장
리스트명.append(값)     # 요소 추가
리스트명.insert(인덱스, 값) # 특정 위치에 요소를 삽입
리스트명.remove(값)  # 특정 값을 가진 요소를 제거
리스트명.pop() # 가장 최근에 입력된 데이터 삭제하고 반환
리스트명.sort() # 요소들을 오름차순으로 정렬
리스트명.sort(reverse=True) # 요소들을 내림차순으로 정렬
리스트명.reverse()  # 요소들의 순서를 거꾸로 뒤집기
리스트명.clear()    # 모든 요소들을 삭제
리스트명.index(값)  # 특정 값을 가진 요소의 인덱스 반환
리스트명.count(값)  # 특정 값을 가진 요소의 수
리스트명 = [연산식 for 지역변수 in 컬렉션타입변수 if 조건식]    # 주어진 조건에 만족하는 요소만 별도로 추출하여 리스트에 내포
리스트명 = 리스트[시작인덱스:끝인덱스:간격] # 특정 요소를 슬라이싱하여 다른 리스트로 분리
리스트 = [[값, 값], [값, 값], [값, 값]]     # 2차원 리스트
리스트 = [[[값, 값], [값, 값]], [[값, 값], [값, 값]], [[값, 값], [값, 값]]]    # 3차원 리스트
리스트명 = list(컬렉션타입)     # tuple, set을 리스트 타입으로 형변환이 가능 
```

#### 리스트 관련 메소드
| 메서드 | 설명 |
|-------------|---------------------------------------------------------|
| append(값) | 리스트 끝에 값을 추가 |
| extend(리스트) | 리스트 끝에 다른 리스트 한꺼번에 추가하여 확장 |
| insert(인덱스, 값) | 리스트의 특정 인덱스에 값을 삽입 |
| pop() | 리스트의 마지막 값을 삭제한 뒤 삭제한 값을 반환 |
| remove(값) | 리스트에서 특정 값을 삭제 |
| index(값) | 리스트에서 특정 값의 인덱스를 구함 |
| count(값) | 리스트에서 특정 값의 개수를 구함 |
| reverse() | 리스트에서 값의 순서를 반대로 뒤집음 |
| sort() | 리스트의 값을 작은 순서대로 정렬(오름차순) |
| sort(reverse=True) | reverse=True는 큰 순서대로 정렬(내림차순) |
| clear() | 리스트의 모든 값을 삭제, del a[:]와 같음 |
| copy() | 리스트를 복사하여 새 리스트 생성 |


### tuple(튜플)
    다른 프로그래밍언어에서는 없는 컬렉션으로 소괄호 "()"로 묶어서 선언하게 되며, 인덱스(순번)에 의한 순서제어가 가능하며,
    요소들의 값이 중복될 수도 있지만, 요소를 추가, 삽입, 삭제, 변경이 불가능하다는 특징이 있어 값을 고정시킬 필요가 있을 때 활용한다.
    또한, 각 요소들에 접근은 허용이 되고, 분리하여 다른 튜플로 선언하거나 여러 튜플을 합치기하여 다른 튜플로 만들기도 가능하다.
```Python
튜플명 = (값1, 값2, 값3,....)       # 튜플 선언
튜플명[인덱스]         # 특정 요소에 접근은 가능함
len(튜플명)   # 튜플의 요소 개수
튜플명=튜플1+튜플2    # 튜플 합치기
max(튜플명) # 튜플에서의 최대값
min(튜플명) # 튜플에서의 최소값
sum(튜플명) # 튜플값의 합계
튜플명.index(값)  # 특정 값을 가진 요소의 인덱스 반환
튜플명.count(값)  # 특정 값을 가진 요소의 수
튜플명 = (연산식 for 지역변수 in 컬렉션타입변수 if 조건식)    # 주어진 조건에 만족하는 요소만 별도로 추출하여 튜플에 내포
튜플명 = 튜플[시작인덱스:끝인덱스:간격] # 특정 요소를 슬라이싱하여 다른 튜플로 분리
튜플 = ((값, 값), (값, 값), (값, 값))     # 2차원 튜플
튜플 = (((값, 값), (값, 값)), ((값, 값), (값, 값)), ((값, 값), (값, 값)))    # 3차원 튜플
튜플명 = tuple(컬렉션타입)      # list, set을 튜플로 형변환 가능
```
**※ 튜플은 요소에 대한 추가, 삭제, 수정을 할 수 없으므로 append, insert, extend, del, remove, pop, clear, sort, sorted, reverse, reversed 등의 메소드는 활용할 수 없음**


#### 튜플 관련 내장 함수 및 메소드
| 함수 및 메서드 | 설명 |
|-------------|---------------------------------------------------------|
| len(튜플명) | 튜플의 요소의 수 |
| max(튜플명) | 튜플 요소의 최대값 |
| min(튜플명) | 튜플 요소의 최소값 |
| sum(튜플명) | 튜플 요소의 합계 |
| index(값) | 튜플에서 특정 값의 인덱스를 구함 |
| count(값) | 튜플에서 특정 값의 개수를 구함 |


### set(셋)
    컬렉션타입으로 중괄호 "{}"로 묶어서 선언하게 되며, 인덱스(순번)가 없기 때문에 순서제어가 불가능하며, 순서유지도 되지 않지만, 값이 중복되는 것을
    허용하지 않으며, 요소를 자유롭게 추가, 삽입, 삭제, 변경이 가능하고, 각 요소들에 접근과, 요소 분리, 합치기, 집합연산 등도 가능하다.
```Python
셋명 = {값1, 값2, 값3,....}       # 셋 선언
len(셋명)   # 셋의 요소 개수
셋명=셋1+셋2    # 셋 합치기
셋명.add(값)     # 요소 추가
셋명.remove(값)  # 특정 값을 가진 요소를 제거하지만, 없으면 에러 발생
셋명.discard(값)  # 특정 값을 가진 요소를 제거하고, 없으면 에러 발생되지 않음
셋명.pop() # 가장 최근에 입력된 데이터 삭제하고 반환
셋명.clear()    # 모든 요소들을 삭제
셋명 = {연산식 for 지역변수 in 컬렉션타입변수 if 조건식}    # 주어진 조건에 만족하는 요소만 별도로 추출하여 셋에 내포
셋 = {{값, 값}, {값, 값}, {값, 값}}     # 2차원 셋
셋 = {{{값, 값}, {값, 값}}, {{값, 값}, {값, 값}}, {{값, 값}, {값, 값}}}    # 3차원 셋
셋명 = set(컬렉션타입)      # list, tuple은 셋으로 형변환 가능
```
**※ 셋은 중복된 값을 허용하지 않으며, 인덱스 개념이 적용되지 않는다.**


#### 셋 관련 메소드
| 메서드 | 연산자 | 설명 |
|-------------|----------|---------------------------------------------------|
| set.union(셋1, 셋2) | &#124; | 두 셋의 합집합 |
| set.intersection(셋1, 셋2) | & | 두 셋의 교집합 |
| set.difference(셋1, 셋2) | - | 두 셋의 차집합 |
| set.symmetric_difference(셋1, 셋2) | ^ | 두 셋의 대칭차집합 |
| update(다른셋) | &#124;= | 현재 셋에 다른 셋를 더함 |
| intersection_update(다른셋) | &= | 현재 셋와 다른 셋 중에서 겹치는 요소만 현재 셋에 저장 |
| difference_update(다른셋) | -= | 현재 셋에서 다른 셋를 뺌 |
| symmetric_difference_update(다른셋) | ^= | 현재 셋와 다른 셋 중에서 겹치지 않는 요소만 현재 셋에 저장 |
| issubset(다른셋) | <= | 현재 셋가 다른 셋의 부분집합인지 확인 |
|  | < | 현재 셋가 다른 셋의 진부분집합인지 확인 |
| issuperset(다른셋) | >= | 현재 셋가 다른 셋의 상위집합인지 확인 |
|  | > | 현재 셋가 다른 셋의 진상위집합인지 확인 |
| isdisjoint(다른셋) |  | 현재 셋가 다른 셋와 겹치지 않는지 확인 |
| add(값) |  | 셋에 요소를 추가 |
| remove(값) |  | 셋에서 특정 요소를 삭제, 없으면 에러 발생 |
| discard(값) |  | 셋에서 특정 요소를 삭제, 요소가 없으면 그냥 넘어감 |
| pop() |  | 셋에서 임의의 요소를 삭제하고 해당 요소를 반환 |
| clear() |  | 셋에서 모든 요소를 삭제 |
| copy() |  | 셋를 복사하여 새로운 셋 생성 |

<br>

### dict(딕트) = Dictionary(딕셔너리)
    컬렉션타입으로 중괄호 "{}"로 묶고, 항상 키와 값으로 선언하게 되며, 인덱스(순번)로 값의 위치를 찾는 게 아니라 키로 제어를 해야하며, 키는 중복되지 않아야 함.
    요소를 자유롭게 추가, 삽입, 삭제, 변경이 가능하되, 키와 값으로 모두 제어되고, 각 요소들에 접근과 요소 분리, 합치기 등도 가능하다.
```Python
딕트명 = {"키1":값1, "키2":값2, "키3":값3,....}       # 딕트 선언
딕트명=딕트1 + 딕트2    # 합치기 - 합칠 때 중복된 키가 있으면 안됨
del 딕트명["키"]    # 요소 삭제
for 변수 in 딕셔너리:              # 모든 키를 꺼내옴
    반복할 코드
 
for 키, 값 in 딕셔너리.items():    # 모든 키와 값을 꺼내옴
    반복할 코드
 
for 키 in 딕셔너리.keys():         # 모든 키를 꺼내옴
    반복할 코드
 
for 값 in 딕셔너리.values():       # 모든 값을 꺼내옴
    반복할 코드
컬렉션명=[("값1", 값),("값2",값),("값3", 값)]   # 리스트 안에 튜플의 구조로 처음 값이 키 적용 가능형태야 한다.
딕트명=dict(컬렉션명)       # 딕트로 형변환
```
**※ 딕트(딕셔너리)는 중복된 키를 허용하지 않으며, 인덱스 개념보다는 키에 의해 값을 접근한다.**


#### 딕트(딕셔너리) 관련 메소드
| 메서드 | 설명 |
|-------------|-------------------------------------------------------------|
| setdefault(키, 기본값) | 딕셔너리에 키-값 쌍을 추가, 키만 지정하면 값에 None을 저장 |
| update(키=값) | 딕셔너리에서 키의 값을 수정, |
| update(딕셔너리) | 딕셔너리에 키가 없으면 키-값 쌍을 추가  |
| update(리스트) | 리스트 데이터를 딕셔너리에 업데이트  |
| update(튜플) | 튜플 데이터를 딕셔너리에 업데이트 |
| update(반복가능한객체) | 딕셔너리에 반복가능한 객체 추가  |
| pop(키) | 딕셔너리에서 특정 키-값 쌍을 삭제한 뒤 값을 반환 |
| pop(키, 기본값) | del 딕셔너리[키]와 같음. 기본값을 지정하면 키가 없을 때 기본 값을 반환 |
| popitem() | 딕셔너리에서 임의의 키-값 쌍을 삭제하고 해당 키-값 쌍을 튜플로 반환 |
| clear() | 딕셔너리의 모든 키-값 쌍을 삭제 |
| get(키) | 딕셔너리에서 특정 키의 값을 가져옴.  |
| get(키, 기본값) | 기본값을 지정하면 키가 없을 때 기본값을 반환 |
| items() | items는 딕셔너리의 키-값 쌍을 모두 가져옴 |
| keys()  | keys는 딕셔너리의 키를 모두 가져옴  |
| values() | values는 딕셔너리의 값을 모두 가져옴 |
| copy() | 딕셔너리를 복사하여 새 딕셔너리 생성 |
| dict.fromkeys(키리스트) | 리스트(튜플)로 딕셔너리를 만듦, 키 리스트만 지정하면 값은 모두 None이 저장됨 |
| dict.fromkeys(키리스트, 값) | 키 리스트와 값을 지정하면 해당 값이 딕셔너리의 값으로 저장됨 |

<br>

---------------------------------------------------------------------------------------

<br>

## 클래스(Class)
    파이썬에서의 클래스는 객체를 생성하기 위한 틀로서 멤버 변수와 멤버 메소드, 생성자, 소멸자, 객체연산 등을 선언하여 활용할 수 있다.
```Python
class 클래스이름:        # 클래스 만들기
    멤버변수 = 초기값

    def __init__(self, 매개변수1,..)        # 생성자 만들기 - 생성자를 선언하지 않아도 기본 생성자가 있어 생략가능
        self.멤버변수 = 매개변수1
        ...

    def 멤버메소드(self):    # 메서드 만들기 - 사용자가 해당 기능을 구현하기 위한 메소드
        실행문장
        ...
    
    @staticmethod    # 정적 메서드 만들기 - 객체 생성없이 직접 해당 클래스로 부터 메소드를 구현하는 경우만 선언
    def 메소드(매개변수1, 매개변수2):
        실행문장
        ...

    @classmethod    # 클래스 메서드 만들기 - 필요한 경우만 선언
    def 메서드(cls, 매개변수1, 매개변수2):
        실행문장
        ....

    @abstractmethod
    def 메서드이름(self):   # 추상 메서드 만들기
        ....    

    def __del__(self):      # 소멸자 만들기 - 소멸자를 선언하지 않아도 기본 소멸자가 있어 생략가능
        실행문장

인스턴스 = 클래스()         # 인스턴스(객체) 만들기
인스턴스.속성               # 인스턴스 속성에 접근
인스턴스.메소드(매개값1,...)    # 인스턴스 메소드 호출

class 자식클래스이름(부모클래스이름):    # 부모 클래스를 상속받음
    추가멤버변수 또는 속성
    def __init__(self):
            super().__init__()              # super()로 부모 클래스의 메서드 호출
            super().속성                    # super()로 부모 클래스의 멤버변수에 접근
            super(자식클래스, self).속성    # super에 부모 클래스와 self를 넣는 형식
    메소드오버라이딩
    ....
```

<br>

--------------------------------------------------------------------------------

<br>

## 함수(Function)
    파이썬의 함수에는 네 가지 종류가 있으며, 이는 자주 사용하는 실행문장이나 복잡한 구조의 명령들을 하나의 이름으로 모아 사용시 호출하도록 기능을 집약하기 위해 필요하다.

```Python
def 함수1():    # 매개변수X 리턴X 함수 만들기
    실행문장

def 함수2(매개변수1, 매개변수2):    # 매개변수O 리턴X 함수 만들기
    실행문장

def 함수3():    # 매개변수X 리턴O 함수 만들기
    ....
    return 반환값

def 함수4(매개변수1, 매개변수2):    # 매개변수O 리턴O 함수 만들기
    return 반환값
    .....

# 각 함수의 호출
함수1()
함수2(인수1, 인수2)
변수 = 함수3()
변수 = 함수4(인수1, 인수2)

# 재귀함수
def factorial(n):   # 재귀호출로 팩토리얼을 구하는 함수
    if n == 1:      # n이 1일 때
        return 1    # 1을 반환하고 재귀호출을 끝냄
    return n * factorial(n - 1)    # n과 factorial 함수에 n - 1을 넣어서 반환된 값을 곱함

fact = factorial(100)
print("결과 : ", fact)
```